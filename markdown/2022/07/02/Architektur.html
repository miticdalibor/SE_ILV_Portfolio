<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary_large_image" /><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>02 Architektur | Portfolio Frunch Infinity 2.0</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="02 Architektur" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Dieser Post beschreibt angewandte Architekturen und Tools für Frunch Infinity 2.0" />
<meta property="og:description" content="Dieser Post beschreibt angewandte Architekturen und Tools für Frunch Infinity 2.0" />
<link rel="canonical" href="https://miticdalibor.github.io/SE_ILV_Portfolio/markdown/2022/07/02/Architektur.html" />
<meta property="og:url" content="https://miticdalibor.github.io/SE_ILV_Portfolio/markdown/2022/07/02/Architektur.html" />
<meta property="og:site_name" content="Portfolio Frunch Infinity 2.0" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-07-02T00:00:00-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="02 Architektur" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-07-02T00:00:00-05:00","datePublished":"2022-07-02T00:00:00-05:00","description":"Dieser Post beschreibt angewandte Architekturen und Tools für Frunch Infinity 2.0","headline":"02 Architektur","mainEntityOfPage":{"@type":"WebPage","@id":"https://miticdalibor.github.io/SE_ILV_Portfolio/markdown/2022/07/02/Architektur.html"},"url":"https://miticdalibor.github.io/SE_ILV_Portfolio/markdown/2022/07/02/Architektur.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/SE_ILV_Portfolio/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://miticdalibor.github.io/SE_ILV_Portfolio/feed.xml" title="Portfolio Frunch Infinity 2.0" /><link rel="shortcut icon" type="image/x-icon" href="/SE_ILV_Portfolio/images/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Primer/15.2.0/primer.css" integrity="sha512-xTz2ys4coGAOz8vuV1NcQBkgVmKhsSEtjbqyMJbBHRplFuvKIUo6xhLHpAyPt9mfR6twHJgn9OgVLuqOvjeBhg==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous" />

<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/SE_ILV_Portfolio/">Portfolio Frunch Infinity 2.0</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/SE_ILV_Portfolio/about/">About Me</a><a class="page-link" href="/SE_ILV_Portfolio/search/">Search</a><a class="page-link" href="/SE_ILV_Portfolio/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">02 Architektur</h1><p class="page-description">Dieser Post beschreibt angewandte Architekturen und Tools für Frunch Infinity 2.0</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2022-07-02T00:00:00-05:00" itemprop="datePublished">
        Jul 2, 2022
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      4 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/SE_ILV_Portfolio/categories/#markdown">markdown</a>
        
      
      </p>
    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul id="toc" class="section-nav">
<li class="toc-entry toc-h1"><a href="#systemarchitektur">Systemarchitektur</a>
<ul>
<li class="toc-entry toc-h2"><a href="#schnittstellen">Schnittstellen</a></li>
<li class="toc-entry toc-h2"><a href="#systemarchitektur-diagramm">Systemarchitektur Diagramm</a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#datawarehouse">Datawarehouse</a></li>
<li class="toc-entry toc-h1"><a href="#cicd-pipeline">CI/CD Pipeline</a></li>
<li class="toc-entry toc-h1"><a href="#data-science-architektur">Data-Science Architektur</a></li>
</ul><h1 id="systemarchitektur">
<a class="anchor" href="#systemarchitektur" aria-hidden="true"><span class="octicon octicon-link"></span></a>Systemarchitektur</h1>
<p style="text-align: justify;">Die Systemarchitektur für Frunch Infinity 2.0 stellt eine Client-Server-Architektur dar. Dabei soll der User entsprechend über den Client die Applikation im Browser öffnen und dort dessen Datensatz importieren und die Ergebnisse entsprechend lesen können. Das Trainieren der Modelle läuft im Backend auf der Server-Seite. Deshalb ist es notwendig hier den Server entsprechend für hohe Rechenleistungen auszulegen, damit auch große Datensätze verarbeitet werden können. Das Backend wird in Python implementiert und die Daten werden entsprechend in einem Data-Warehouse abgelegt. Das Frontend wird in React umgesetzt, um flexibel in der Implementierung der Web-App zu sein und auf spezifische User-Anforderungen reagieren zu können. Das Frontend benötigt die Daten vom Backend im .json Format, damit es diese in der Web-App verarbeiten kann. Hierzu wird FastAPI implementiert, da es Flexibilität im Datenaustausch bietet, sehr performant ist und automatisch eine Dokumentation generiert. Eine mobile App ist für Frunch Infinity 2.0 nicht erforderlich, da die Datensätze vom User nicht auf einem iPhone liegen. </p>

<h2 id="schnittstellen">
<a class="anchor" href="#schnittstellen" aria-hidden="true"><span class="octicon octicon-link"></span></a>Schnittstellen</h2>
<p style="text-align: justify;">Da Frunch Infinity 2.0 eine Enterprise Solution ist, soll das System im firmeneigenen Intranet aufgesetzt werden, damit die Kunden die Daten nicht nach außen vergeben müssen. Deshalb muss auch die Verwaltung und das Management der Server-Hardware von der IT-Abteilung des Kunden erfolgen. Somit sind folgende Schnittstellen nicht anwendbar:</p>
<p style="text-align: justify;">- Schnittstellen zu Internet-Webseiten und Web-Scraper</p>
<p style="text-align: justify;">- Schnittstellen zu Cloud-Services (Datawarehouse liegt beim Kunden)</p>
<p style="text-align: justify;">- Schnittstelle zu Softwareentwickler, da kein Transfer-Learning mit geteilten Daten angewendet wird</p>

<p style="text-align: justify;">Für das ablegen der Docker-Registry auf Dockerhub ist entsprechend die Schnittstelle vom Intranet nach außen erforderlich. Außerdem müssen entsprechende Downloads von Packages gewährleistet werden. Hierbei sollen die Packages nur mit Hashes installiert werden, um keine "gefälschten" Open-Source Packages zu installieren.</p>

<h2 id="systemarchitektur-diagramm">
<a class="anchor" href="#systemarchitektur-diagramm" aria-hidden="true"><span class="octicon octicon-link"></span></a>Systemarchitektur Diagramm</h2>

<p style="text-align: justify;">Die nachfolgende Grafik zeigt eine Übersicht der Architektur. Die gelb markierten Blöcke befinden sich im Frontend und die blau markierten Blöcke im Backend.</p>

<p><img src="/SE_ILV_Portfolio/diagrams/Systemarchitektur.svg" alt="" title="Systemarchitektur und Tools"></p>

<p style="text-align: justify;">Der User soll dabei die Daten aus dem lokalen Speicher in einem .csv Format über die Web-App (Client) hochladen. Über die Web-App soll der User dann die Feature-Bezeichnungen definieren und entsprechend als numerisch oder kategorisch markieren, sowie die Zielvariable auswählen. Sobald die Funktion gestartet wird, werden die Daten entsprechend über eine Pipeline preprocessed und im Datawarehouse abgelegt (Server). Von dort aus werden die preprocessed Daten geladen, die Modelle trainiert und die Ergebnisse entsprechend gespeichert und ausgegeben.</p>

<h1 id="datawarehouse">
<a class="anchor" href="#datawarehouse" aria-hidden="true"><span class="octicon octicon-link"></span></a>Datawarehouse</h1>
<p style="text-align: justify;">Als Datawarehouse für Frunch Infinity ist ein Enterprise Data Warehouse erforderlich, damit die Daten zentralisiert gelagert werden. Für die Architektur der untersten Ebene im Datawarehouse können keine besonderen Anforderungen außer der Konsistenz der Daten abgeleitet werden. Die Zeit für das Schreiben und Lesen der Daten im Datawarehouse ist im Vergleich zur Trainingszeit der Modelle marginal und somit besteht keine Echtzeitanforderung. Es ist aber wichtig, dass die Daten konsistent sind, damit die Integrität der Daten über den gesamten Lebenszyklus gegeben ist. Deshalb wird als Architektur ein relationales DBS (MySQL) gewählt. Der Zugriff auf das Datawarehouse kann über SQLAlchemy (ORM) erfolgen und für die Verwaltung der importierten Datensätze wird DVC (Data Version Control) verwendet (bevor sie in das Datawarehouse abgelegt werden). </p>

<h1 id="cicd-pipeline">
<a class="anchor" href="#cicd-pipeline" aria-hidden="true"><span class="octicon octicon-link"></span></a>CI/CD Pipeline</h1>

<p>Die CI/CD Pipeline für Frunch Infinity 2.0 enthält folgende Stages:</p>
<ul>
  <li>
    <p style="text-align: justify;">Test: Ausführen der unit-tests (run pytest)</p>
  </li>
  <li>
    <p style="text-align: justify;">Pages: Ausführen von pdoc, um Dokumentation der Klassen zu erstellen.</p>
  </li>
  <li>
    <p style="text-align: justify;">Build: Erstellen eines Docker-Images und speichert in einer Registry auf Gitlab. Die Build-Stage soll nur beim Tag (neuer Software Release) ausgeführt werden.</p>
  </li>
  <li>
    <p style="text-align: justify;">Deploy: Die Applikation soll aus dem Docker-Image auf einem lokalen Server deployed werden, wenn ein Release erfolgreich gebuilded wurde. </p>
  </li>
</ul>

<p style="text-align: justify;">Beispiel: Entwicklung des Features "import Data", mit dem der User eigene .csv-Files über die Web-App hochladen kann. </p>

<p style="text-align: justify;">1) pytest wird um eine Klasse "test_file_format" erweitert. Dabei wird ein assert error eingefügt, der die File-Extension "*.csv" überprüft und entsprechend einen Fehler "Please import only files in .csv file format" ausgibt.</p>

<p style="text-align: justify;">2) Implementierung in Web-App durchführen und importierte Daten als .json an Backend übergeben.</p>
<p style="text-align: justify;">3) Commit durchführen</p>
<p style="text-align: justify;">4) Pytest in CI wird durchgeführt. Wenn Test bestanden hat, dann weiter mit Schritt 5. </p>
<p style="text-align: justify;">5) Doc-String von Klassen "test_file_format" und "import_data" wird mit pdoc erstellt und als html abgelegt.</p>
<p style="text-align: justify;">6) Feature releasen in Gitlab. </p>
<p style="text-align: justify;">7) Build wird durchgeführt (siehe oben)</p>
<p style="text-align: justify;">8) App wird deployed.</p>

<h1 id="data-science-architektur">
<a class="anchor" href="#data-science-architektur" aria-hidden="true"><span class="octicon octicon-link"></span></a>Data-Science Architektur</h1>
<p style="text-align: justify;">Nachfolgendes Diagramm zeigt eine eigens entwickelte Data-Science Architektur für Frunch-Infinity 2.0 auf Basis des CRISP-DM Ansatzes, welches in der Produktion angewendet wird. Für den Development Prozess kann der klassische CRISP-DM Ansatz angewendet werden und deshalb wird dieser hier nicht näher betrachtet. </p>

<p><img src="/SE_ILV_Portfolio/diagrams/DS_Architektur.svg" alt="" title="Data Science Architektur"></p>

<p style="text-align: justify;">Da Frunch-Infinity eine Auto-ML Lösung darstellt, liegt der Business Understanding (Domänenwissen) auf der User-Seite. Der User soll durch die Anwendung von Frunch-Infinity 2.0 einen Einblick in die Qualität der verwendeten Daten kriegen und somit das Verständnis der Daten verbessern. Damit das System flexibel ist muss die Data-Preparation und das Modelling ein Netzwerk darstellen, wodurch alle möglichen Szenarien durchberechnet werden. Der Evaluation-Teil vergleicht die Ergebnisse der Modelle und schaltet mit jeder Iteration durch alle Pipelines. Wenn alle Iterationen durchgelaufen sind, vergleicht der Evaluation-Teil die besten Ergebnisse der Iterationen mit einander und gibt das Modell mit dem besten Ergebnis aus. Am meisten Entwicklungsaufwand für Frunch-Infinity 2.0 wird der Teil Data Preprocessing sein, da die Pipeline unterschiedlichste Datensätze und Edge-Cases verarbeiten muss. Die Architektur soll die Möglichkeit bieten, dem User die Data Preparation sowie das beste Modell ausgeben, wodurch das Data Understanding durch die Anwendung von Frunch Infinity 2.0 erreicht wird.</p>


  </div><a class="u-url" href="/SE_ILV_Portfolio/markdown/2022/07/02/Architektur.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/SE_ILV_Portfolio/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/SE_ILV_Portfolio/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/SE_ILV_Portfolio/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>This website is powered by fastpages (https://github.com/fastai/fastpages)</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/miticdalibor" target="_blank" title="miticdalibor"><svg class="svg-icon grey"><use xlink:href="/SE_ILV_Portfolio/assets/minima-social-icons.svg#github"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
